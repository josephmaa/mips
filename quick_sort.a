.data

numbers: .word 8 2 7 10 5 6 3 4 9 3 1
length:  .word 11

.text
.globl main

main:

la $a0, numbers # Start main
li $a1, 0
lw $a2, length
addi $a2, $a2, -1
jal quickSort

li $v0, 10
syscall

quickSort:
# Use quick sort on numbers array.
#
# Input:
# a0: Start address of array with n integers
# a1: Integer low
# a2: Integer high
#
# Intermediate values:
#
# s0-s2: Argument parameters
# s3: pivotPosition
#
# Output:
# Sorts array in-place.

# We have to store 5 values on the stack (including the return address).
addi $sp, $sp, -20 # Start quickSort
sw $ra, ($sp)
sw $s0, 4($sp)
sw $s1, 8($sp)
sw $s2, 12($sp)
sw $s3, 16($sp)

move $s0, $a0
move $s1, $a1
move $s2, $a2

if:
bge $a1, $a2, end_if

move $a0, $s0
move $a1, $s1
move $a2, $s2
jal partition # pivotPosition is placed into register $v0

move $a0, $s0
move $a1, $s1
move $s3, $v0 
addi $v0, $v0, -1
move $a2, $v0
jal quickSort

move $a0, $s0
move $a1, $s3
addi $a1, $a1, 1
move $a2, $s2
jal quickSort

end_if:

# Restore values back (including the return address).
lw $ra, ($sp)
lw $s0, 4($sp)
lw $s1, 8($sp)
lw $s2, 12($sp)
lw $s3, 16($sp)
addi $sp, $sp, 20

jr $ra

swap:
# Swap should exchange the memory value at the two addresses passed it. Swap does not call any subprograms.
#
# Input:
# a0: address of integer operand 1.
# a1: address of integer operand 2.
#
# Intermediate values:
#
# t0: temp address value of integer operand 1
# t1: value of integer operand 1
# t2: value of integer operand 2
#
# Output:
# Swaps the memory values in-place.

move $t0, $a0 # Start swap
lw $t1, ($a0)
lw $t2, ($a1)

sw $t2, ($a0)
sw $t1, ($a1)

jr $ra

partition:
# Partition should split the array based on the pivot value arbitrarily selected as the low element in the array. 
#
# Input:
# a0: start address of array with n integers.
# a1: integer low.
# a2: integer high.
#
# Intermediate values:
# s0-2: saved parameter values
# s3: right value before swap is called
# s4: pivot value before swap is called
# t0: left index
# t1: right index
# t2: current pivot value
# t3: current right value
# t4: intermediate if condition value
# t5: current left value
# t6: intermediate if condition value
# t7: right value address
# t8: pivot address
#
# Output:
# v0: an integer value corresponding to the index of the pivot.

# We have to store 6 values on the stack.
addi $sp, $sp, -24 # setup call-frame # Start partition
sw $ra, ($sp) # save the return addr to get back to main
sw $s0, 4($sp) # save main's s-registers if it is
sw $s1, 8($sp) # using any
sw $s2, 12($sp)
sw $s3, 16($sp)
sw $s4, 20($sp)

# Save the parameter values in the save registers.
move $s0, $a0
move $s1, $a1
move $s2, $a2

# Save left in $t0.
move $t0, $s1

# Save right in $t1.
move $t1, $s2

# Save current pivot value in $t2.
mul $t2, $s1, 4
add $t2, $t2, $s0
lw $t2, ($t2)

while_left_lt_right:
bge $t0, $t1, end_while_left_lt_right

while_array_right_gt_pivot:
# Calculate the right value.
move $t3, $t1
mul $t3, $t3, 4
add $t3, $t3, $s0
lw $t3, ($t3)
ble $t3, $t2, end_while_array_right_gt_pivot
addi $t1, $t1, -1
j while_array_right_gt_pivot

end_while_array_right_gt_pivot:

while_left_lt_right_and_left_element_lte_pivot:
# Check left is less than right element.
sge $t4, $t0, $t1

# Calculate the left value
move $t5, $t0
mul $t5, $t5, 4
add $t5, $t5, $s0
lw $t5, ($t5)

# Check left element is less than equal to pivot.
sgt $t6, $t5, $t2

# Combine the logic for breaking out of the second while loop. If left >= right or array[left] > pivot, their respective conditions will set their registers to a non-zero value. Or-ing the respective bytes and comparing it to zero will yield a non-zero value to break if either is true.

or $t6, $t6, $t4
bne $t6, $zero, end_while_left_lt_right_and_left_element_lte_pivot
addi $t0, $t0, 1
j while_left_lt_right_and_left_element_lte_pivot

end_while_left_lt_right_and_left_element_lte_pivot:

if_left_lt_right:
bge $t0, $t1, end_if_left_lt_right

# Calculate array[left]
move $t5, $t0
mul $t5, $t5, 4
add $t5, $t5, $s0
move $a0, $t5

# Calculate array[right]
move $t3, $t1 
mul $t3, $t3, 4
add $t3, $t3, $s0
move $a1, $t3
# After returning from the swap function, we can make no assumptions about any information stored in the temp registers. Therefore, store the variables we need (right index, pivot value) into save registers as well.
move $s3, $t1
move $s4, $t2
jal swap

end_if_left_lt_right:

j while_left_lt_right

end_while_left_lt_right:

# Calculate array[right]
move $t1, $s3
mul $t7, $t1, 4
add $t7, $t7, $s0
lw $t3, ($t7)

# Calculate the address of array[low]
move $t8, $s1
mul $t8, $t8, 4
add $t8, $t8, $s0

sw $t3, ($t8)
sw $s4, ($t7) 

move $v0, $s3

lw $ra, ($sp) 
lw $s0, 4($sp) 
lw $s1, 8($sp)
lw $s2, 12($sp)
lw $s3, 16($sp)
lw $s4, 20($sp)
addi $sp, $sp, 24 # setup call-frame

jr $ra


